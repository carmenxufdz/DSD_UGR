/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include <math.h>

double *
suma_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 + arg2;
	return &result;
}

double *
resta_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 - arg2;
	return &result;
}

double *
multiplica_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 * arg2;
	return &result;
}

double *
divide_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 / arg2;
	return &result;

}

int *
modulo_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static int  result;
	result = arg1 % arg2;
	return &result;
}

int *
potencia_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static int  result;
	result = pow(arg1,arg2);
	return &result;
}

double *
raiz_1_svc(double arg1, int arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = pow(arg1,(1/arg2));
	return &result;
}

int *
factorial_1_svc(int arg1,  struct svc_req *rqstp)
{
	static int  result = 1;
	for(int i=1; i<=arg1 && result!=-1; i++){
		if(i>(INT_MAX/result)){		//En caso de que haya overflow se pone a -1 y se sale
			result=-1;
		}
		else
			result*=i;
	}
	return &result;
}

double *
logaritmo_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = log(arg1)/log(arg2);
	return &result;
}

double *
log_n_1_svc(int arg1,  struct svc_req *rqstp)
{
	static double  result;
	result = log(arg1);
	return &result;
}

double *
log10_1_svc(int arg1,  struct svc_req *rqstp)
{
	static double  result;
	result = log10(arg1);
	return &result;
}

double *
seno_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = sin(radian);
	return &result;
}

double *
coseno_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = cos(radian);
	return &result;
}

double *
tangente_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = tan(radian);
	return &result;
}

vector3D *
sumavectorial_1_svc(vector3D arg1, vector3D arg2,  struct svc_req *rqstp)
{
	static vector3D  result;
	result.x = arg1.x + arg2.x;
	result.y = arg1.y + arg2.y;
	result.z = arg1.z + arg2.z;
	return &result;
}

vector3D *
restavectorial_1_svc(vector3D arg1, vector3D arg2,  struct svc_req *rqstp)
{
	static vector3D  result;
	result.x = arg1.x - arg2.x;
	result.y = arg1.y - arg2.y;
	result.z = arg1.z - arg2.z;
	return &result;
}

vector3D *
multporescalar_1_svc(vector3D arg1, int arg2,  struct svc_req *rqstp)
{
	static vector3D  result;
	result.x = arg1.x * arg2;
	result.y = arg1.y * arg2;
	result.z = arg1.z * arg2;
	return &result;
}

int *
productoescalar_1_svc(vector3D arg1, vector3D arg2,  struct svc_req *rqstp)
{
	static int  result;
	result = (arg1.x * arg2.x + arg1.y * arg2.y + arg1.z * arg2.z);
	return &result;
}

vector3D *
productovectorial_1_svc(vector3D arg1, vector3D arg2,  struct svc_req *rqstp)
{
	static vector3D  result;
	result.x = (arg1.y * arg2.z) - (arg1.z * arg2.y);
	result.y = (arg1.z * arg2.x) - (arg1.x * arg2.z);
	result.z = (arg1.x * arg2.y) - (arg1.y * arg2.x);
	return &result;
}

matrix *
sumamatricial_1_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;

	return &result;
}

matrix *
restamatricial_1_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;

	return &result;
}

matrix *
multmatricial_1_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;

	return &result;
}
