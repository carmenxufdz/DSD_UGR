/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include <math.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>

double *
suma_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 + arg2;
	return &result;
}

double *
resta_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 - arg2;
	return &result;
}

double *
multiplica_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 * arg2;
	return &result;
}

double *
divide_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = arg1 / arg2;
	return &result;

}

int *
modulo_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static int  result;
	result = arg1 % arg2;
	return &result;
}

int *
potencia_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static int  result;
	result = pow(arg1,arg2);
	return &result;
}

double *
raiz_1_svc(double arg1, double arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = pow(arg1,(1/arg2));
	return &result;
}

int *
factorial_1_svc(int arg1,  struct svc_req *rqstp)
{
	static int  result = 1;
	for(int i=1; i<=arg1 && result!=-1; i++){
		if(i>(INT_MAX/result)){		//En caso de que haya overflow se pone a -1 y se sale
			result=-1;
		}
		else
			result*=i;
	}
	return &result;
}

double *
logaritmo_1_svc(int arg1, int arg2,  struct svc_req *rqstp)
{
	static double  result;
	result = log(arg1)/log(arg2);
	return &result;
}

double *
log_n_1_svc(int arg1,  struct svc_req *rqstp)
{
	static double  result;
	result = log(arg1);
	return &result;
}

double *
log10_1_svc(int arg1,  struct svc_req *rqstp)
{
	static double  result;
	result = log10(arg1);
	return &result;
}

double *
seno_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = sin(radian);
	return &result;
}

double *
coseno_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = cos(radian);
	return &result;
}

double *
tangente_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	if(radian == (M_PI/2))
	{
		printf("Tangente = infinito\n");
		result = -1;
	}
	else
		result = tan(radian);
	return &result;
}

double *
cosecante_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = 1/sin(radian);
	return &result;
}

double *
secante_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	result = 1/cos(radian);
	return &result;
}

double *
cotangente_1_svc(double arg1,  struct svc_req *rqstp)
{
	static double  result;
	double radian = arg1 * M_PI / 180;
	if(radian == (M_PI/2))
	{
		printf("Tangente = infinito\n");
		result = -1;
	}
	else
		result = 1/tan(radian);
	return &result;
}

v *
sumavectorial_1_svc(v arg1, v arg2,  struct svc_req *rqstp)
{
	static v result;
	xdr_free((xdrproc_t)xdr_double, result.v_val);
	
	result.v_len=arg1.v_len;
	result.v_val=malloc(arg2.v_len*sizeof(int));

	for(int i=0; i<arg1.v_len; i++)
		result.v_val[i] = arg1.v_val[i] + arg2.v_val[i];

	return &result;
}

v *
restavectorial_1_svc(v arg1, v arg2,  struct svc_req *rqstp)
{
	static v result;
	xdr_free((xdrproc_t)xdr_double, result.v_val);
	
	result.v_len=arg1.v_len;
	result.v_val=malloc(arg2.v_len*sizeof(int));

	for(int i=0; i<arg1.v_len; i++)
		result.v_val[i] = arg1.v_val[i] - arg2.v_val[i];

	return &result;
}

v *
multiplicaporescalar_1_svc(v arg1, double arg2,  struct svc_req *rqstp)
{
	static v result;
	xdr_free((xdrproc_t)xdr_double, result.v_val);
	
	result.v_len=arg1.v_len;
	result.v_val=malloc(arg1.v_len*sizeof(int));

	for(int i=0; i<arg1.v_len; i++)
		result.v_val[i] = arg1.v_val[i] * arg2;

	return &result;
}

double *
productoescalar_1_svc(v arg1, v arg2,  struct svc_req *rqstp)
{
	static double result;
	
	for(int i=0; i<arg1.v_len; i++)
		result += arg1.v_val[i] * arg2.v_val[i];

	return &result;
}

v *
productovectorial_1_svc(v arg1, v arg2,  struct svc_req *rqstp)
{
	static v result;
	xdr_free((xdrproc_t)xdr_double, result.v_val);
	
	result.v_len=arg1.v_len;
	result.v_val=malloc(arg2.v_len*sizeof(int));

	result.v_val[0] = arg1.v_val[1]*arg2.v_val[2] - arg1.v_val[2]*arg2.v_val[1];
	result.v_val[1] = arg1.v_val[2]*arg2.v_val[0] - arg1.v_val[0]*arg2.v_val[2];
	result.v_val[2] = arg1.v_val[0]*arg2.v_val[1] - arg1.v_val[1]*arg2.v_val[0];

	return &result;
}

matrix *
sumamatricial_1_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;
	xdr_free((xdrproc_t)xdr_double, result.m.m_val);
	result.m.m_len=0;

	result.fil=arg1.fil;
	result.col=arg1.col;

	result.m.m_val=calloc(result.fil*result.col, sizeof(double));
	result.m.m_len=result.fil*result.col;

	for(int i=0; i<arg1.fil; i++)
		for(int j=0; j<arg1.col; j++)
			result.m.m_val[i*result.col+j]=arg1.m.m_val[i*result.col+j]+arg2.m.m_val[i*result.col+j];

	return &result;
}

matrix *
restamatricial_1_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;
	xdr_free((xdrproc_t)xdr_double, result.m.m_val);
	result.m.m_len=0;

	result.fil=arg1.fil;
	result.col=arg1.col;

	result.m.m_val=calloc(result.fil*result.col, sizeof(double));
	result.m.m_len=result.fil*result.col;

	for(int i=0; i<arg1.fil; i++)
		for(int j=0; j<arg1.col; j++)
			result.m.m_val[i*result.col+j]=arg1.m.m_val[i*result.col+j]-arg2.m.m_val[i*result.col+j];
	return &result;
}

matrix *
multmatricial_1_svc(matrix arg1, matrix arg2,  struct svc_req *rqstp)
{
	static matrix  result;
	xdr_free((xdrproc_t)xdr_double, result.m.m_val);
	result.m.m_len=0;

	result.fil=arg1.fil;
	result.col=arg2.col;

	result.m.m_val=calloc(result.fil*result.col, sizeof(double));
	result.m.m_len=result.fil*result.col;


	for(int i=0; i<result.fil; i++)
		for(int j=0; j<result.col; j++)
			result.m.m_val[i*result.col+j]=0;

	for(int i=0; i<arg1.fil; i++)
		for(int j=0; j<arg2.col; j++)
			for(int k=0; k<arg1.col; k++)
				result.m.m_val[i*result.col+j]+=arg1.m.m_val[i*arg1.col+k]*arg2.m.m_val[k*arg2.col+j];
	return &result;
}
